---
// Network Background Animation Component
// Inspired by nathy-graph.com network animation
// Adapts to light and dark mode
---

<div class="network-background-container">
  <canvas id="network-canvas" class="network-canvas"></canvas>
</div>

<style>
  .network-background-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    overflow: hidden;
    pointer-events: none;
    transition: background 0.3s ease;
  }

  /* Light mode background (default) */
  .network-background-container {
    background: linear-gradient(135deg, #f5f5f5 0%, #e5e5e5 50%, #fafafa 100%);
  }

  /* Dark mode background */
  html.dark .network-background-container {
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0d0d0d 100%);
  }

  .network-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<script>
  class NetworkAnimation {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.nodes = [];
      this.connections = [];
      this.particles = [];
      this.geometricShapes = [];
      this.ripples = [];
      this.stars = [];
      this.vapors = [];
      this.mouse = { x: 0, y: 0 };
      this.nodeCount = 60;
      this.connectionDistance = 180;
      this.nodeSpeed = 0.4;
      this.isDarkMode = false;
      this.time = 0;
      
      this.resize();
      this.initNodes();
      this.initParticles();
      this.initGeometricShapes();
      this.initStars();
      this.initVapors();
      this.setupThemeListener();
      this.animate();
      
      window.addEventListener('resize', () => {
        this.resize();
        // Recalculate marmite position after resize
        setTimeout(() => {
          if (this.vapors.length > 0) {
            this.initVapors();
          }
        }, 100);
      });
      
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        this.mouse.x = e.clientX - rect.left;
        this.mouse.y = e.clientY - rect.top;
      });
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        this.addRipple(e.clientX - rect.left, e.clientY - rect.top);
      });
      
      // Update vapors position when page scrolls (if marmite moves)
      let lastScrollY = window.scrollY;
      window.addEventListener('scroll', () => {
        if (Math.abs(window.scrollY - lastScrollY) > 50) {
          lastScrollY = window.scrollY;
          // Vapors will update their position on next frame via getMarmitePosition
        }
      });
    }

    checkDarkMode() {
      return document.documentElement.classList.contains('dark');
    }

    setupThemeListener() {
      // Update initial state
      this.isDarkMode = this.checkDarkMode();
      
      // Listen for theme changes from HSThemeAppearance
      window.addEventListener('on-hs-appearance-change', (e) => {
        this.isDarkMode = e.detail === 'dark';
        this.updateColors();
      });
      
      // Also check for class changes on html element (fallback)
      const observer = new MutationObserver(() => {
        const newDarkMode = this.checkDarkMode();
        if (newDarkMode !== this.isDarkMode) {
          this.isDarkMode = newDarkMode;
          this.updateColors();
        }
      });
      
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class']
      });
    }

    updateColors() {
      // Reinitialize particles and stars with new theme-appropriate counts
      if (this.particles.length > 0) {
        this.initParticles();
      }
      if (this.stars.length > 0) {
        this.initStars();
      }
      if (this.vapors.length > 0) {
        this.initVapors();
      }
    }

    updateParticles() {
      this.particles.forEach(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;

        if (particle.x < 0 || particle.x > this.canvas.width) particle.vx *= -1;
        if (particle.y < 0 || particle.y > this.canvas.height) particle.vy *= -1;

        particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
        particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));

        particle.pulse += 0.02;
        particle.opacity = 0.2 + Math.sin(particle.pulse) * 0.3;
      });
    }

    updateGeometricShapes() {
      this.geometricShapes.forEach(shape => {
        shape.rotation += shape.rotationSpeed;
        shape.pulse += shape.pulseSpeed;
      });
    }

    updateRipples() {
      this.ripples = this.ripples.filter(ripple => {
        ripple.radius += ripple.speed;
        ripple.opacity -= 0.01;
        return ripple.radius < ripple.maxRadius && ripple.opacity > 0;
      });
    }

    updateStars() {
      this.stars.forEach(star => {
        star.twinkle += star.twinkleSpeed;
        star.opacity = 0.2 + Math.sin(star.twinkle) * 0.6;
      });
    }

    updateVapors() {
      const marmitePos = this.getMarmitePosition();
      
      this.vapors.forEach((vapor, index) => {
        // Update position with turbulence
        vapor.noise += vapor.noiseSpeed;
        const noiseX = Math.sin(vapor.noise) * vapor.turbulence;
        const noiseY = Math.cos(vapor.noise * 1.3) * vapor.turbulence * 0.5;
        
        vapor.x += vapor.vx + noiseX;
        vapor.y += vapor.vy + noiseY;
        
        // Grow over time (vapors expand as they rise)
        if (vapor.size < vapor.maxSize) {
          vapor.size += vapor.sizeSpeed;
        }
        
        // Fade and brighten in a cycle
        vapor.opacity += vapor.opacitySpeed;
        if (vapor.opacity > 0.25 || vapor.opacity < 0.05) {
          vapor.opacitySpeed *= -1;
        }
        
        // Reset if it goes off screen - return to marmite if available
        if (vapor.y < -vapor.size || vapor.x < -vapor.size || vapor.x > this.canvas.width + vapor.size) {
          if (marmitePos && vapor.sourceX !== undefined) {
            // Return to marmite position
            const spreadWidth = marmitePos.width * 0.6;
            vapor.x = marmitePos.x + (Math.random() - 0.5) * spreadWidth;
            vapor.y = marmitePos.y;
            vapor.size = Math.random() * 25 + 20;
            vapor.opacity = Math.random() * 0.2 + 0.1;
            vapor.opacitySpeed = Math.random() * 0.003 + 0.001;
            vapor.vx = (Math.random() - 0.5) * 0.4;
            vapor.vy = -(Math.random() * 0.8 + 0.4);
          } else {
            // Fallback behavior
            vapor.x = Math.random() * this.canvas.width;
            vapor.y = this.canvas.height * (0.7 + Math.random() * 0.3);
            vapor.size = Math.random() * 40 + 30;
            vapor.opacity = Math.random() * 0.15 + 0.05;
            vapor.opacitySpeed = Math.random() * 0.002 + 0.001;
          }
        }
      });
      
      // Periodically add new vapors from marmite (every few frames)
      if (marmitePos && this.time % 30 === 0 && this.vapors.length < 25) {
        const spreadWidth = marmitePos.width * 0.6;
        this.vapors.push({
          x: marmitePos.x + (Math.random() - 0.5) * spreadWidth,
          y: marmitePos.y,
          vx: (Math.random() - 0.5) * 0.4,
          vy: -(Math.random() * 0.8 + 0.4),
          size: Math.random() * 25 + 20,
          maxSize: Math.random() * 100 + 80,
          opacity: Math.random() * 0.2 + 0.1,
          opacitySpeed: Math.random() * 0.003 + 0.001,
          sizeSpeed: Math.random() * 0.15 + 0.08,
          noise: Math.random() * Math.PI * 2,
          noiseSpeed: Math.random() * 0.03 + 0.015,
          turbulence: Math.random() * 0.8 + 0.3,
          sourceX: marmitePos.x,
          sourceY: marmitePos.y,
        });
      }
    }

    getNodeColors() {
      if (this.isDarkMode) {
        return {
          glowStart: 'rgba(251, 146, 60, ', // orange-400
          glowMid: 'rgba(251, 191, 36, ', // yellow-400
          core: 'rgba(251, 146, 60, ',
          center: 'rgba(255, 255, 255, 1)',
          connectionStart: 'rgba(251, 146, 60, ',
          connectionMid: 'rgba(251, 191, 36, ',
          connectionEnd: 'rgba(251, 146, 60, '
        };
      } else {
        return {
          glowStart: 'rgba(249, 115, 22, ', // orange-500
          glowMid: 'rgba(251, 191, 36, ', // yellow-400
          core: 'rgba(249, 115, 22, ',
          center: 'rgba(255, 255, 255, 1)',
          connectionStart: 'rgba(249, 115, 22, ',
          connectionMid: 'rgba(234, 179, 8, ', // yellow-500
          connectionEnd: 'rgba(249, 115, 22, '
        };
      }
    }

    resize() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      // Reinitialize nodes on resize
      if (this.nodes.length > 0) {
        this.initNodes();
      }
      if (this.particles.length > 0) {
        this.initParticles();
      }
      if (this.geometricShapes.length > 0) {
        this.initGeometricShapes();
      }
      if (this.stars.length > 0) {
        this.initStars();
      }
      if (this.vapors.length > 0) {
        // Wait a bit for layout to settle
        setTimeout(() => {
          this.initVapors();
        }, 50);
      }
    }

    initParticles() {
      this.particles = [];
      const count = this.isDarkMode ? 80 : 50;
      for (let i = 0; i < count; i++) {
        this.particles.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          radius: Math.random() * 1.5 + 0.5,
          opacity: Math.random() * 0.5 + 0.2,
          pulse: Math.random() * Math.PI * 2,
        });
      }
    }

    initGeometricShapes() {
      this.geometricShapes = [];
      const count = 12;
      for (let i = 0; i < count; i++) {
        this.geometricShapes.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          size: Math.random() * 30 + 20,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.01,
          pulse: Math.random() * Math.PI * 2,
          pulseSpeed: Math.random() * 0.02 + 0.01,
          type: Math.floor(Math.random() * 3), // 0: triangle, 1: square, 2: hexagon
        });
      }
    }

    initStars() {
      this.stars = [];
      const count = this.isDarkMode ? 100 : 60;
      for (let i = 0; i < count; i++) {
        this.stars.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          size: Math.random() * 2 + 1,
          opacity: Math.random() * 0.8 + 0.2,
          twinkle: Math.random() * Math.PI * 2,
          twinkleSpeed: Math.random() * 0.05 + 0.02,
        });
      }
    }

    getMarmitePosition() {
      const marmiteImg = document.getElementById('marmite-image');
      if (!marmiteImg) return null;
      
      const rect = marmiteImg.getBoundingClientRect();
      const canvasRect = this.canvas.getBoundingClientRect();
      
      // Position relative to canvas
      return {
        x: rect.left - canvasRect.left + rect.width / 2,
        y: rect.top - canvasRect.top + rect.height * 0.3, // Top of the pot (30% from top)
        width: rect.width,
        height: rect.height
      };
    }

    initVapors() {
      this.vapors = [];
      const marmitePos = this.getMarmitePosition();
      
      if (marmitePos) {
        // Vapors coming from the marmite
        const count = 20;
        const spreadWidth = marmitePos.width * 0.6; // Vapor spread at the top of the pot
        
        for (let i = 0; i < count; i++) {
          this.vapors.push({
            x: marmitePos.x + (Math.random() - 0.5) * spreadWidth,
            y: marmitePos.y,
            vx: (Math.random() - 0.5) * 0.4, // Horizontal drift
            vy: -(Math.random() * 0.8 + 0.4), // Always move upward, faster
            size: Math.random() * 25 + 20, // Start smaller
            maxSize: Math.random() * 100 + 80, // Grow larger as it rises
            opacity: Math.random() * 0.2 + 0.1,
            opacitySpeed: Math.random() * 0.003 + 0.001,
            sizeSpeed: Math.random() * 0.15 + 0.08,
            noise: Math.random() * Math.PI * 2,
            noiseSpeed: Math.random() * 0.03 + 0.015,
            turbulence: Math.random() * 0.8 + 0.3,
            sourceX: marmitePos.x,
            sourceY: marmitePos.y,
          });
        }
      } else {
        // Fallback: create vapors from bottom-middle if marmite not found
        const count = 15;
        for (let i = 0; i < count; i++) {
          const baseY = this.canvas.height * (0.5 + Math.random() * 0.5);
          this.vapors.push({
            x: Math.random() * this.canvas.width,
            y: baseY,
            baseY: baseY,
            vx: (Math.random() - 0.5) * 0.3,
            vy: -(Math.random() * 0.5 + 0.3),
            size: Math.random() * 40 + 30,
            maxSize: Math.random() * 80 + 60,
            opacity: Math.random() * 0.15 + 0.05,
            opacitySpeed: Math.random() * 0.002 + 0.001,
            sizeSpeed: Math.random() * 0.1 + 0.05,
            noise: Math.random() * Math.PI * 2,
            noiseSpeed: Math.random() * 0.02 + 0.01,
            turbulence: Math.random() * 0.5 + 0.2,
          });
        }
      }
    }

    addRipple(x, y) {
      this.ripples.push({
        x: x,
        y: y,
        radius: 0,
        maxRadius: 200,
        opacity: 0.5,
        speed: 2,
      });
    }

    initNodes() {
      this.nodes = [];
      for (let i = 0; i < this.nodeCount; i++) {
        this.nodes.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          vx: (Math.random() - 0.5) * this.nodeSpeed,
          vy: (Math.random() - 0.5) * this.nodeSpeed,
          radius: Math.random() * 2.5 + 2,
          glow: Math.random() * 0.4 + 0.6,
          pulse: Math.random() * Math.PI * 2,
        });
      }
    }

    updateNodes() {
      this.nodes.forEach(node => {
        // Update position
        node.x += node.vx;
        node.y += node.vy;

        // Bounce off edges
        if (node.x < 0 || node.x > this.canvas.width) node.vx *= -1;
        if (node.y < 0 || node.y > this.canvas.height) node.vy *= -1;

        // Keep within bounds
        node.x = Math.max(0, Math.min(this.canvas.width, node.x));
        node.y = Math.max(0, Math.min(this.canvas.height, node.y));

        // Mouse interaction
        const dx = this.mouse.x - node.x;
        const dy = this.mouse.y - node.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 100) {
          const force = (100 - distance) / 100;
          node.vx -= (dx / distance) * force * 0.02;
          node.vy -= (dy / distance) * force * 0.02;
        }

        // Pulse animation
        node.pulse += 0.02;
        node.glow = 0.5 + Math.sin(node.pulse) * 0.3;
      });
    }

    drawConnections() {
      this.connections = [];
      const colors = this.getNodeColors();
      const baseOpacity = this.isDarkMode ? 0.4 : 0.25;
      
      for (let i = 0; i < this.nodes.length; i++) {
        for (let j = i + 1; j < this.nodes.length; j++) {
          const dx = this.nodes[i].x - this.nodes[j].x;
          const dy = this.nodes[i].y - this.nodes[j].y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < this.connectionDistance) {
            const opacity = (1 - distance / this.connectionDistance) * baseOpacity;
            this.connections.push({
              from: this.nodes[i],
              to: this.nodes[j],
              opacity: opacity,
              distance: distance
            });
          }
        }
      }

      // Draw connections
      this.connections.forEach(conn => {
        this.ctx.beginPath();
        this.ctx.moveTo(conn.from.x, conn.from.y);
        this.ctx.lineTo(conn.to.x, conn.to.y);
        
        // Gradient for connection line
        const gradient = this.ctx.createLinearGradient(
          conn.from.x, conn.from.y,
          conn.to.x, conn.to.y
        );
        gradient.addColorStop(0, colors.connectionStart + conn.opacity + ')');
        gradient.addColorStop(0.5, colors.connectionMid + conn.opacity + ')');
        gradient.addColorStop(1, colors.connectionEnd + conn.opacity + ')');
        
        this.ctx.strokeStyle = gradient;
        this.ctx.lineWidth = this.isDarkMode ? 1 : 0.8;
        this.ctx.stroke();
      });
    }

    drawNodes() {
      const colors = this.getNodeColors();
      const glowIntensity = this.isDarkMode ? 0.9 : 0.6;
      
      this.nodes.forEach(node => {
        // Outer glow
        const gradient = this.ctx.createRadialGradient(
          node.x, node.y, 0,
          node.x, node.y, node.radius * 5
        );
        gradient.addColorStop(0, colors.glowStart + (node.glow * glowIntensity) + ')');
        gradient.addColorStop(0.4, colors.glowMid + (node.glow * glowIntensity * 0.5) + ')');
        gradient.addColorStop(0.8, colors.glowStart + (node.glow * glowIntensity * 0.2) + ')');
        gradient.addColorStop(1, colors.glowStart + '0)');

        this.ctx.beginPath();
        this.ctx.arc(node.x, node.y, node.radius * 4, 0, Math.PI * 2);
        this.ctx.fillStyle = gradient;
        this.ctx.fill();

        // Node core
        this.ctx.beginPath();
        this.ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        this.ctx.fillStyle = colors.core + node.glow + ')';
        this.ctx.fill();
        
        // Bright center (less intense in light mode)
        const centerOpacity = this.isDarkMode ? 1 : 0.8;
        this.ctx.beginPath();
        this.ctx.arc(node.x, node.y, node.radius * 0.5, 0, Math.PI * 2);
        this.ctx.fillStyle = `rgba(255, 255, 255, ${centerOpacity})`;
        this.ctx.fill();
      });
    }

    drawParticles() {
      const colors = this.getNodeColors();
      const baseColor = this.isDarkMode ? 'rgba(251, 191, 36, ' : 'rgba(234, 179, 8, ';
      
      this.particles.forEach(particle => {
        this.ctx.beginPath();
        this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        this.ctx.fillStyle = baseColor + particle.opacity + ')';
        this.ctx.fill();
      });
    }

    drawGeometricShapes() {
      const colors = this.getNodeColors();
      const baseColor = this.isDarkMode ? 'rgba(251, 146, 60, ' : 'rgba(249, 115, 22, ';
      
      this.geometricShapes.forEach(shape => {
        const size = shape.size + Math.sin(shape.pulse) * 5;
        const opacity = 0.1 + Math.sin(shape.pulse) * 0.1;
        
        this.ctx.save();
        this.ctx.translate(shape.x, shape.y);
        this.ctx.rotate(shape.rotation);
        this.ctx.globalAlpha = opacity;
        this.ctx.strokeStyle = baseColor + '0.3)';
        this.ctx.lineWidth = 1;
        
        this.ctx.beginPath();
        if (shape.type === 0) {
          // Triangle
          this.ctx.moveTo(0, -size);
          this.ctx.lineTo(size * 0.866, size * 0.5);
          this.ctx.lineTo(-size * 0.866, size * 0.5);
          this.ctx.closePath();
        } else if (shape.type === 1) {
          // Square
          this.ctx.rect(-size / 2, -size / 2, size, size);
        } else {
          // Hexagon
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const x = Math.cos(angle) * size / 2;
            const y = Math.sin(angle) * size / 2;
            if (i === 0) {
              this.ctx.moveTo(x, y);
            } else {
              this.ctx.lineTo(x, y);
            }
          }
          this.ctx.closePath();
        }
        this.ctx.stroke();
        this.ctx.restore();
      });
    }

    drawRipples() {
      const colors = this.getNodeColors();
      const baseColor = this.isDarkMode ? 'rgba(251, 146, 60, ' : 'rgba(249, 115, 22, ';
      
      this.ripples.forEach(ripple => {
        this.ctx.beginPath();
        this.ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
        this.ctx.strokeStyle = baseColor + ripple.opacity + ')';
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
        
        // Inner ring
        this.ctx.beginPath();
        this.ctx.arc(ripple.x, ripple.y, ripple.radius * 0.7, 0, Math.PI * 2);
        this.ctx.strokeStyle = baseColor + (ripple.opacity * 0.5) + ')';
        this.ctx.lineWidth = 1;
        this.ctx.stroke();
      });
    }

    drawStars() {
      const starColor = this.isDarkMode ? 'rgba(255, 255, 255, ' : 'rgba(251, 191, 36, ';
      
      this.stars.forEach(star => {
        this.ctx.beginPath();
        this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        this.ctx.fillStyle = starColor + star.opacity + ')';
        this.ctx.fill();
        
        // Cross pattern for stars
        this.ctx.strokeStyle = starColor + (star.opacity * 0.5) + ')';
        this.ctx.lineWidth = 0.5;
        this.ctx.beginPath();
        this.ctx.moveTo(star.x - star.size * 2, star.y);
        this.ctx.lineTo(star.x + star.size * 2, star.y);
        this.ctx.moveTo(star.x, star.y - star.size * 2);
        this.ctx.lineTo(star.x, star.y + star.size * 2);
        this.ctx.stroke();
      });
    }

    drawVapors() {
      const baseColor = this.isDarkMode ? 'rgba(251, 146, 60, ' : 'rgba(234, 179, 8, ';
      
      this.vapors.forEach(vapor => {
        // Draw multiple circles to create a cloud/vapor effect
        this.ctx.save();
        this.ctx.globalAlpha = vapor.opacity;
        
        // Main cloud body
        const gradient = this.ctx.createRadialGradient(
          vapor.x, vapor.y, 0,
          vapor.x, vapor.y, vapor.size
        );
        gradient.addColorStop(0, baseColor + '0.3)');
        gradient.addColorStop(0.5, baseColor + '0.15)');
        gradient.addColorStop(1, baseColor + '0)');
        
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(vapor.x, vapor.y, vapor.size, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Additional smaller circles for organic shape
        const numCircles = 4;
        for (let i = 0; i < numCircles; i++) {
          const angle = (i / numCircles) * Math.PI * 2;
          const offsetX = Math.cos(angle + vapor.noise) * vapor.size * 0.6;
          const offsetY = Math.sin(angle + vapor.noise) * vapor.size * 0.4;
          // Use a deterministic size based on index and noise for consistency
          const sizeVariation = 0.4 + (Math.sin(vapor.noise + i) * 0.15 + 0.15);
          const smallSize = vapor.size * sizeVariation;
          
          const smallGradient = this.ctx.createRadialGradient(
            vapor.x + offsetX, vapor.y + offsetY, 0,
            vapor.x + offsetX, vapor.y + offsetY, smallSize
          );
          smallGradient.addColorStop(0, baseColor + '0.2)');
          smallGradient.addColorStop(0.7, baseColor + '0.08)');
          smallGradient.addColorStop(1, baseColor + '0)');
          
          this.ctx.fillStyle = smallGradient;
          this.ctx.beginPath();
          this.ctx.arc(vapor.x + offsetX, vapor.y + offsetY, smallSize, 0, Math.PI * 2);
          this.ctx.fill();
        }
        
        this.ctx.restore();
      });
    }

    animate() {
      this.time += 0.016; // ~60fps
      
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      // Draw in layers for proper depth (background to foreground)
      this.updateVapors();
      this.drawVapors();
      
      this.updateStars();
      this.drawStars();
      
      this.updateParticles();
      this.drawParticles();
      
      this.updateGeometricShapes();
      this.drawGeometricShapes();
      
      this.updateNodes();
      this.drawConnections();
      this.drawNodes();
      
      this.updateRipples();
      this.drawRipples();

      requestAnimationFrame(() => this.animate());
    }
  }

  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('network-canvas');
    if (canvas) {
      // Wait a bit for images to load and positions to be calculated
      setTimeout(() => {
        new NetworkAnimation(canvas);
      }, 100);
    }
  });
</script>