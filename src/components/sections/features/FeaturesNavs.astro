---
// Import the necessary dependencies
import TabNav from "@components/ui/blocks/TabNav.astro";
import TabContent from "@components/ui/blocks/TabContent.astro";
import Icon from "@components/ui/icons/Icon.astro";

// Define props from Astro
const { title, tabs } = Astro.props;

// Define TypeScript interface for tab object
interface Tab {
  heading: string;
  content: string;
  svg: string;
  src: any;
  alt: string;
  first?: boolean;
  second?: boolean;
  video?: boolean;
  width?: number;
  height?: number;
}

// Define TypeScript interface for props
interface Props {
  title?: string;
  tabs: Tab[];
}
---

<section
  class="mx-auto max-w-[85rem] px-4 py-10 sm:px-6 lg:px-8 lg:py-14 2xl:max-w-full"
>
  <div class="relative p-6 md:p-16">
    <div
      class="relative z-10 lg:grid lg:grid-cols-12 lg:items-center"
      style="gap: 0.5rem;"
    >
      <!-- Section's heading and tab navigation -->
      <div class="mb-10 lg:order-2 lg:col-span-5 lg:col-start-8 lg:mb-0 lg:pr-1">
        <h2
          class="text-2xl font-bold text-neutral-800 dark:text-neutral-200 sm:text-3xl"
        >
          <!-- About Fragment: https://docs.astro.build/en/basics/astro-syntax/#fragments -->
          <Fragment set:html={title} />
        </h2>
        <!-- Tab navigation - use the attribute 'first' in the first TabNav for the component to work -->
        <nav class="mt-5 grid gap-4 md:mt-10" aria-label="Tabs" role="tablist">
          {
            tabs.map((tab, index) => (
              <TabNav
                id={`tabs-with-card-item-${index + 1}`}
                dataTab={`#tabs-with-card-${index + 1}`}
                aria={`tabs-with-card-${index + 1}`}
                heading={tab.heading}
                content={tab.content}
                first={tab.first}
              >
                <Icon name={tab.svg} />
              </TabNav>
            ))
          }
        </nav>
      </div>

      <!-- Contents for each tab - the 'first' attribute should be used in the first tab for that tab to be initially visible, 'second' changes the styles -->
      <div class="lg:col-span-7 lg:pl-0 lg:ml-8">
        <div class="relative min-h-[400px] md:min-h-[500px]">
          <div class="relative w-full h-full flex items-center justify-start">
            {
              tabs.map((tab, index) => (
                <TabContent
                  id={`tabs-with-card-${index + 1}`}
                  aria={`tabs-with-card-item-${index + 1}`}
                  src={tab.src}
                  alt={tab.alt}
                  first={tab.first}
                  second={tab.second}
                  video={tab.video}
                  width={tab.width}
                  height={tab.height}
                />
              ))
            }
          </div>
        </div>
      </div>
    </div>

    <div class="absolute inset-0 grid h-full w-full grid-cols-12">
      <!-- Decorative background and sizing -->
      <div
        class="col-span-full h-4/6 w-full rounded-xl bg-neutral-100 dark:bg-white/[.075] sm:h-3/4 lg:col-span-7 lg:col-start-6 lg:h-full"
      >
      </div>
    </div>
  </div>
</section>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Get all tab buttons and content panels
    const tabButtons = document.querySelectorAll('[data-hs-tab]');
    const tabContents = document.querySelectorAll('[role="tabpanel"]');
    
    let isTransitioning = false;
    let currentActiveButton: Element | null = null;
    
    // Initialize: set first tab as active and ensure it's visible
    tabButtons.forEach((btn) => {
      if (btn.classList.contains('active')) {
        currentActiveButton = btn;
        const targetId = btn.getAttribute('data-hs-tab');
        if (targetId) {
          const targetContent = document.querySelector(targetId) as HTMLElement;
          if (targetContent) {
            targetContent.classList.remove('hidden');
            targetContent.style.opacity = '1';
          }
        }
      }
    });
    
    // Ensure all other tabs are hidden
    tabContents.forEach((content) => {
      const contentEl = content as HTMLElement;
      if (contentEl.classList.contains('hidden')) {
        contentEl.style.opacity = '0';
      } else {
        contentEl.style.opacity = '1';
      }
    });
    
    tabButtons.forEach((button) => {
      const targetId = button.getAttribute('data-hs-tab');
      
      // Handle hover (mouseenter)
      button.addEventListener('mouseenter', () => {
        // Prevent rapid switching
        if (isTransitioning || button === currentActiveButton) {
          return;
        }
        
        isTransitioning = true;
        
        // Use requestAnimationFrame for smooth transition
        requestAnimationFrame(() => {
          // Hide all tab contents with fade out
          tabContents.forEach((content) => {
            const contentEl = content as HTMLElement;
            if (!contentEl.classList.contains('hidden')) {
              contentEl.style.opacity = '0';
              setTimeout(() => {
                contentEl.classList.add('hidden');
              }, 150);
            }
          });
          
          // Remove active class from all buttons
          tabButtons.forEach((btn) => {
            btn.classList.remove('active');
            btn.classList.remove('hs-tab-active');
          });
          
          // Show the target content with fade in
          if (targetId) {
            const targetContent = document.querySelector(targetId) as HTMLElement;
            if (targetContent) {
              targetContent.classList.remove('hidden');
              // Force reflow
              void targetContent.offsetHeight;
              requestAnimationFrame(() => {
                targetContent.style.opacity = '1';
              });
            }
          }
          
          // Add active class to current button
          button.classList.add('active');
          button.classList.add('hs-tab-active');
          
          // Update current active button
          currentActiveButton = button;
          
          // Reset transition flag after animation
          setTimeout(() => {
            isTransitioning = false;
          }, 300);
        });
      });
    });
  });
</script>
